---
const { autoplay = false } = Astro.props;
---

<section class="component" data-component="ClocksClock">
  <div class="wrapper rounded-sm shadow-md dark:shadow-xl">
    <template data-template="digit">
      <div class="digit">
        <div class="∅"></div><div class="∅"></div><div class="∅"></div><div class="∅">
        </div>
        <div class="∅"></div><div class="∅"></div><div class="∅"></div><div class="∅">
        </div>
        <div class="∅"></div><div class="∅"></div><div class="∅"></div><div class="∅">
        </div>
        <div class="∅"></div><div class="∅"></div><div class="∅"></div><div class="∅">
        </div>
        <div class="∅"></div><div class="∅"></div><div class="∅"></div><div class="∅">
        </div>
        <div class="∅"></div><div class="∅"></div><div class="∅"></div><div class="∅">
        </div>
      </div>
    </template>

    <div class="display" data-target="display"></div>
  </div>

  <div
    class="controls mt-4 flex flex-wrap gap-2"
    hidden={autoplay}
    data-target="controls"
    data-autoplay={autoplay}
  >
    <button
      type="button"
      disabled
      data-action="play"
      class="flex items-center space-x-2 rounded-sm border-2
        outline-none focus-visible:outline-none
        disabled:cursor-not-allowed disabled:opacity-75
        border-zinc-700 dark:border-zinc-300 py-1 px-3 text-sm transition-colors
        bg-white enabled:hover:bg-zinc-50 enabled:active:bg-zinc-200 enabled:hover:inset-shadow-xs enabled:active:inset-shadow-2xs
        dark:bg-zinc-800 dark:enabled:hover:bg-zinc-700 dark:enabled:active:bg-zinc-600
        focus:border-orange-400 dark:focus:border-pink-400"
    >
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 16 16"
        fill="currentColor"
        class="size-4"
        role="presentation"
      >
        <path
          d="M3 3.732a1.5 1.5 0 0 1 2.305-1.265l6.706 4.267a1.5 1.5 0 0 1 0 2.531l-6.706 4.268A1.5 1.5 0 0 1 3 12.267V3.732Z"
        ></path>
      </svg>
      <span>Run</span>
    </button>

    <button
      type="button"
      disabled
      data-action="pause"
      class="flex items-center space-x-2 rounded-sm border-2
        outline-none focus-visible:outline-none
        disabled:cursor-not-allowed disabled:opacity-75
        border-zinc-700 dark:border-zinc-300 py-1 px-3 text-sm transition-colors
        bg-white enabled:hover:bg-zinc-50 enabled:active:bg-zinc-200 enabled:hover:inset-shadow-xs enabled:active:inset-shadow-2xs
        dark:bg-zinc-800 dark:enabled:hover:bg-zinc-700 dark:enabled:active:bg-zinc-600
        focus:border-orange-400 dark:focus:border-pink-400"
    >
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 16 16"
        fill="currentColor"
        class="size-4"
        role="presentation"
      >
        <path
          d="M4.5 2a.5.5 0 0 0-.5.5v11a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-11a.5.5 0 0 0-.5-.5h-1ZM10.5 2a.5.5 0 0 0-.5.5v11a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-11a.5.5 0 0 0-.5-.5h-1Z"
        ></path>
      </svg>

      <span>Pause</span>
    </button>

    <button
      type="button"
      disabled
      data-action="reset"
      class="flex items-center space-x-2 rounded-sm border-2
        outline-none focus-visible:outline-none
        disabled:cursor-not-allowed disabled:opacity-75
        border-zinc-700 dark:border-zinc-300 py-1 px-3 text-sm transition-colors
        bg-white enabled:hover:bg-zinc-50 enabled:active:bg-zinc-200 enabled:hover:inset-shadow-xs enabled:active:inset-shadow-2xs
        dark:bg-zinc-800 dark:enabled:hover:bg-zinc-700 dark:enabled:active:bg-zinc-600
        focus:border-orange-400 dark:focus:border-pink-400"
    >
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 16 16"
        fill="currentColor"
        class="size-4"
        role="presentation"
      >
        <path
          fill-rule="evenodd"
          d="M13.836 2.477a.75.75 0 0 1 .75.75v3.182a.75.75 0 0 1-.75.75h-3.182a.75.75 0 0 1 0-1.5h1.37l-.84-.841a4.5 4.5 0 0 0-7.08.932.75.75 0 0 1-1.3-.75 6 6 0 0 1 9.44-1.242l.842.84V3.227a.75.75 0 0 1 .75-.75Zm-.911 7.5A.75.75 0 0 1 13.199 11a6 6 0 0 1-9.44 1.241l-.84-.84v1.371a.75.75 0 0 1-1.5 0V9.591a.75.75 0 0 1 .75-.75H5.35a.75.75 0 0 1 0 1.5H3.98l.841.841a4.5 4.5 0 0 0 7.08-.932.75.75 0 0 1 1.025-.273Z"
          clip-rule="evenodd"></path>
      </svg>

      <span>Reset</span>
    </button>
  </div>
</section>

<style>
  .component {
    display: flex;
  }
  .wrapper {
    background-color: light-dark(var(--color-white), var(--color-zinc-950));

    max-width: 50rem;
    width: 100%;
    margin: auto;

    padding: 1rem;
    padding: clamp(2px, 1.5vw, 1rem);

    aspect-ratio: 4 / 1;

    & > .display {
      display: flex;
      flex-direction: row;

      gap: 1rem;
      gap: clamp(2px, 1.5vw, 1rem);

      width: 100%;

      --thickness: 12%;

      & > .digit {
        flex: 1 1 0;

        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(6, 1fr);

        gap: 1px;

        & > * {
          outline: none;
          border-radius: 9999px;
          border: 2px solid light-dark(var(--color-zinc-200), var(--color-zinc-900));

          background: linear-gradient(
            135deg,
            light-dark(var(--color-zinc-200), var(--color-zinc-950)) 15%,
            light-dark(var(--color-zinc-50), var(--color-zinc-800))
          );
          box-shadow: 1px 1px 5px light-dark(var(--color-zinc-200), var(--color-zinc-900));

          &::before,
          &::after {
            border-radius: 9999px;
            transition: transform 0.5s ease-in-out;
          }
        }
      }

      & > :nth-child(3) {
        margin-left: 2rem;
        margin-left: clamp(4px, 2.5vw, 2rem);
      }

      & > :nth-child(4) {
        margin-right: 2rem;
        margin-right: clamp(4px, 2.5vw, 2rem);
      }
    }
  }
</style>

<script>
  const ENCODED_DIGITS = `
┌──┐  ┌─┐.  ┌──┐  ┌──┐  ┌┐┌┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐
│┌┐│  └┐│.  └─┐│  └─┐│  ││││  │┌─┘  │┌─┘  └─┐│  │┌┐│  │┌┐│
││││  .││.  ┌─┘│  .┌┘│  │└┘│  │└─┐  │└─┐  ..││  │└┘│  │└┘│
││││  .││.  │┌─┘  .└┐│  └─┐│  └─┐│  │┌┐│  ..││  │┌┐│  └─┐│
│└┘│  ┌┘└┐  │└─┐  ┌─┘│  ..││  ┌─┘│  │└┘│  ..││  │└┘│  ┌─┘│
└──┘  └──┘  └──┘  └──┘  ..└┘  └──┘  └──┘  ..└┘  └──┘  └──┘
`
    .trim()
    .replace(/[\r\n]/g, "")
    .replace(/\./g, "∅");

  const DECODED = Array.from(new Array(10), (_, digit) => {
    const faces: string[] = [];

    const digitWidth = 4;
    const digitHeight = 6;
    const digitGap = 2;

    const rowLength = digitWidth * 10 + digitGap * 9;
    const x = digit * (digitWidth + digitGap);

    for (let y = 0; y < digitHeight; y++) {
      const start = rowLength * y + x;
      const end = start + digitWidth;

      faces.push(...ENCODED_DIGITS.substring(start, end));
    }

    return faces;
  });

  // Reading an angle from a property from a style
  function read(style: CSSStyleDeclaration, property: string): number {
    return Number(style.getPropertyValue(property).replace("deg", ""));
  }

  // Writing an angle to a property on an element's style
  function write(style: CSSStyleDeclaration, property: string, angle: number) {
    style.setProperty(property, `${angle}deg`);
  }

  // Update currentHour and currentMinute based on the given angles
  function nextHands(
    [currentHour, currentMinute]: [number, number],
    [angleA, angleB]: [number, number],
  ): [number, number] {
    // Normalize the current angles to 0 - 360
    const currentRelativeHour = currentHour % 360;
    const currentRelativeMinute = currentMinute % 360;

    // This sorts the angles ensuring that the least amount of degrees will be
    // rotated. This is not a requirement for the solution, but it makes for the
    // least busy transition!
    const [nextRelativeHour, nextRelativeMinute] =
      distance(currentRelativeHour, angleA) + distance(currentRelativeMinute, angleB) <
      distance(currentRelativeHour, angleB) + distance(currentRelativeMinute, angleA)
        ? [angleA, angleB]
        : [angleB, angleA];

    // The new angle must be larger (or equal) to the current, so the distance
    // between the current angle and the next angle is what needs to be added to
    // complete the transition
    return [
      currentHour + distance(currentRelativeHour, nextRelativeHour),
      currentMinute + distance(currentRelativeMinute, nextRelativeMinute),
    ];
  }

  // Calculating the distance between a current hand and a destination
  function distance(subject: number, destination: number) {
    if (subject <= destination) {
      return destination - subject;
    }

    return distance(subject, destination + 360);
  }

  function randomAngle(): number {
    return Math.floor(Math.random() * 360);
  }

  function draw(digit: number, tinyClocks: HTMLCollection) {
    const shapes = DECODED[digit];

    shapes.forEach((tinyClockClass, tinyClockIndex) => {
      const tinyClock = tinyClocks.item(tinyClockIndex) as HTMLElement;
      const tinyClockStyle = window.getComputedStyle(tinyClock);

      const [nextHour, nextMinute] = nextHands(
        [read(tinyClockStyle, "--angle-hour"), read(tinyClockStyle, "--angle-minute")],
        degrees[tinyClockClass],
      );

      write(tinyClock.style, "--angle-hour", nextHour);
      write(tinyClock.style, "--angle-minute", nextMinute);
    });
  }

  function randomize(tinyClocks: HTMLCollection) {
    for (const tinyClock of tinyClocks) {
      if (tinyClock instanceof HTMLElement) {
        write(tinyClock.style, "--angle-hour", randomAngle());
        write(tinyClock.style, "--angle-minute", randomAngle());
      }
    }
  }

  let lastDisplayedTime = 0;
  let isActive = false;

  function check() {
    if (!isActive) {
      return;
    }

    const now = new Date();
    const displayedNow = Math.floor(now.getTime() % 1000);

    if (lastDisplayedTime != displayedNow) {
      lastDisplayedTime = displayedNow;
      redraw(now);
    }

    requestAnimationFrame(check);
  }

  function redraw(now: Date) {
    const hours = now.getHours();
    const minutes = now.getMinutes();
    const seconds = now.getSeconds();

    const digits = [
      Math.floor(hours / 10),
      hours % 10,
      Math.floor(minutes / 10),
      minutes % 10,
      Math.floor(seconds / 10),
      seconds % 10,
    ];

    digits.forEach((digit, index) => {
      draw(digit, collections[index]);
    });
  }

  const collections: HTMLCollection[] = [];
  const degrees: Record<string, [number, number]> = {};

  document.addEventListener("astro:page-load", () => {
    const component = document.querySelector('[data-component="ClocksClock"]');
    if (!component) {
      return;
    }

    const template = component.querySelector<HTMLTemplateElement>(
      'template[data-template="digit"]',
    );
    const target = component.querySelector<HTMLElement>('[data-target="display"]');
    const controls = component.querySelector<HTMLElement>('[data-target="controls"]');

    if (!template || !target || !controls) {
      throw new Error(
        'Expected [data-component] ClocksClock with [data-template="digit"], [data-target="display"], and [data-target="controls"]',
      );
    }

    // Setup digits
    for (let i = 0; i < 6; i++) {
      const clone = template.content.cloneNode(true) as HTMLElement;
      const tinyClocks = clone.firstElementChild!.children;
      collections.push(tinyClocks);

      randomize(tinyClocks);

      target.appendChild(clone);
    }

    // Read all shapes by temporarily turning the first tiny clock's clock into
    // each valid shape. Afterwards remove the temporary tiny clock again.
    const temporaryDigit = document.createElement("div");
    temporaryDigit.classList.add("digit");

    const temporaryTinyClock = document.createElement("div");
    temporaryTinyClock.classList.add("∅");

    temporaryDigit.append(temporaryTinyClock);
    target.append(temporaryDigit);

    const shapes = ["┌", "┐", "┘", "└", "─", "│", "∅"];
    const shapeStyle = window.getComputedStyle(temporaryTinyClock);
    shapes.forEach((shape) => {
      temporaryTinyClock.setAttribute("class", shape);

      const desiredAngleA = read(shapeStyle, "--angle-hour");
      const desiredAngleB = read(shapeStyle, "--angle-minute");

      degrees[shape] = [desiredAngleA, desiredAngleB];
    });

    temporaryDigit.remove();

    controls.addEventListener("click", (event) => {
      const clicked = event.target;
      if (!(clicked instanceof Element)) {
        return;
      }

      const action = clicked.closest("button[data-action]");
      if (!action) {
        return;
      }

      const action_ = action.getAttribute("data-action");
      switch (action_) {
        case "play": {
          if (isActive) {
            return;
          }

          isActive = true;
          requestAnimationFrame(check);
          break;
        }
        case "pause": {
          isActive = false;
          break;
        }
        case "reset": {
          isActive = false;
          collections.forEach((tinyClocks) => randomize(tinyClocks));
          break;
        }
      }
    });

    controls.querySelectorAll("button[data-action]:disabled").forEach((button) => {
      button.removeAttribute("disabled");
    });

    if (controls.getAttribute("data-autoplay") === "true") {
      isActive = true;
      requestAnimationFrame(check);
    }
  });

  document.addEventListener("astro:before-preparation", () => {
    isActive = false;
    collections.splice(0, collections.length);
  });
</script>
