<section data-component="FunctionalClocksClock" class="preview">
  <template data-template="digit">
    <div class="digit">
      <div class="∅"></div><div class="∅"></div><div class="∅"></div><div class="∅"></div>
      <div class="∅"></div><div class="∅"></div><div class="∅"></div><div class="∅"></div>
      <div class="∅"></div><div class="∅"></div><div class="∅"></div><div class="∅"></div>
      <div class="∅"></div><div class="∅"></div><div class="∅"></div><div class="∅"></div>
      <div class="∅"></div><div class="∅"></div><div class="∅"></div><div class="∅"></div>
      <div class="∅"></div><div class="∅"></div><div class="∅"></div><div class="∅"></div>
    </div>
  </template>

  <div class="display" data-target="display"></div>
</section>

<style>
  .preview {
    outline: 1px dotted light-dark(var(--color-zinc-800), var(--color-zinc-200));
    background-color: light-dark(var(--color-white), var(--color-zinc-950));

    max-width: 50rem;
    margin-left: auto;
    margin-right: auto;

    padding: 1rem;
    padding: clamp(2px, 1.5vw, 1rem);

    & > .display {
      display: flex;
      flex-direction: row;

      gap: 1rem;
      gap: clamp(2px, 1.5vw, 1rem);

      width: 100%;

      & > .digit {
        flex: 1 1 0;

        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(6, 1fr);

        gap: 4px;

        & > * {
          outline-color: light-dark(var(--color-zinc-300), var(--color-zinc-700));

          &::before,
          &::after {
            transition: transform 0.5s ease-in-out;
          }
        }
      }

      & > :nth-child(3) {
        margin-left: 2rem;
        margin-left: clamp(4px, 2.5vw, 2rem);
      }

      & > :nth-child(4) {
        margin-right: 2rem;
        margin-right: clamp(4px, 2.5vw, 2rem);
      }
    }
  }
</style>

<script>
  const component = document.querySelector('[data-component="FunctionalClocksClock"]');
  if (!component) {
    throw new Error("Expected [data-component] FunctionalClocksClock");
  }

  const template = component.querySelector<HTMLTemplateElement>(
    'template[data-template="digit"]',
  );
  const target = component.querySelector<HTMLElement>('[data-target="display"]');

  if (!template || !target) {
    throw new Error(
      'Expected [data-component] FunctionalClocksClock with [data-template="digit"] and [data-target="display"]',
    );
  }

  const ENCODED_DIGITS = `
┌──┐  ┌─┐.  ┌──┐  ┌──┐  ┌┐┌┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐
│┌┐│  └┐│.  └─┐│  └─┐│  ││││  │┌─┘  │┌─┘  └─┐│  │┌┐│  │┌┐│
││││  .││.  ┌─┘│  .┌┘│  │└┘│  │└─┐  │└─┐  ..││  │└┘│  │└┘│
││││  .││.  │┌─┘  .└┐│  └─┐│  └─┐│  │┌┐│  ..││  │┌┐│  └─┐│
│└┘│  ┌┘└┐  │└─┐  ┌─┘│  ..││  ┌─┘│  │└┘│  ..││  │└┘│  ┌─┘│
└──┘  └──┘  └──┘  └──┘  ..└┘  └──┘  └──┘  ..└┘  └──┘  └──┘
`
    .trim()
    .replace(/[\r\n]/g, "")
    .replace(/\./g, "∅");

  const DECODED = Array.from(new Array(10), (_, digit) => {
    const faces: string[] = [];

    const digitWidth = 4;
    const digitHeight = 6;
    const digitGap = 2;

    const rowLength = digitWidth * 10 + digitGap * 9;
    const x = digit * (digitWidth + digitGap);

    for (let y = 0; y < digitHeight; y++) {
      const start = rowLength * y + x;
      const end = start + digitWidth;

      faces.push(...ENCODED_DIGITS.substring(start, end));
    }

    return faces;
  });

  // Reading an angle from a property from a style
  function read(style: CSSStyleDeclaration, property: string): number {
    return Number(style.getPropertyValue(property).replace("deg", ""));
  }

  // Writing an angle to a property on an element's style
  function write(style: CSSStyleDeclaration, property: string, angle: number) {
    style.setProperty(property, `${angle}deg`);
  }

  // Update currentHour and currentMinute based on the given angles
  function nextHands(
    [currentHour, currentMinute]: [number, number],
    [angleA, angleB]: [number, number],
  ): [number, number] {
    // Normalize the current angles to 0 - 360
    const currentRelativeHour = currentHour % 360;
    const currentRelativeMinute = currentMinute % 360;

    // This sorts the angles ensuring that the least amount of degrees will be
    // rotated. This is not a requirement for the solution, but it makes for the
    // least busy transition!
    const [nextRelativeHour, nextRelativeMinute] =
      distance(currentRelativeHour, angleA) + distance(currentRelativeMinute, angleB) <
      distance(currentRelativeHour, angleB) + distance(currentRelativeMinute, angleA)
        ? [angleA, angleB]
        : [angleB, angleA];

    // The new angle must be larger (or equal) to the current, so the distance
    // between the current angle and the next angle is what needs to be added to
    // complete the transition
    return [
      currentHour + distance(currentRelativeHour, nextRelativeHour),
      currentMinute + distance(currentRelativeMinute, nextRelativeMinute),
    ];
  }

  // Calculating the distance between a current hand and a destination
  function distance(subject: number, destination: number) {
    if (subject <= destination) {
      return destination - subject;
    }

    return distance(subject, destination + 360);
  }

  function randomAngle(): number {
    return Math.floor(Math.random() * 360);
  }

  function draw(digit: number, tinyClocks: HTMLCollection) {
    const shapes = DECODED[digit];

    shapes.forEach((tinyClockClass, tinyClockIndex) => {
      const tinyClock = tinyClocks.item(tinyClockIndex) as HTMLElement;
      const tinyClockStyle = window.getComputedStyle(tinyClock);

      const [nextHour, nextMinute] = nextHands(
        [read(tinyClockStyle, "--angle-hour"), read(tinyClockStyle, "--angle-minute")],
        degrees[tinyClockClass],
      );

      write(tinyClock.style, "--angle-hour", nextHour);
      write(tinyClock.style, "--angle-minute", nextMinute);
    });
  }

  const collections: HTMLCollection[] = [];

  // Setup digits
  for (let i = 0; i < 6; i++) {
    const clone = template.content.cloneNode(true) as HTMLElement;
    const tinyClocks = clone.firstElementChild!.children;
    collections.push(tinyClocks);

    for (const tinyClock of tinyClocks) {
      if (tinyClock instanceof HTMLElement) {
        write(tinyClock.style, "--angle-hour", randomAngle());
        write(tinyClock.style, "--angle-minute", randomAngle());
      }
    }

    target.appendChild(clone);
  }

  const degrees: Record<string, [number, number]> = {};

  // Read all shapes by temporarily turning the first tiny clock's clock into
  // each valid shape. Afterwards remove the temporary tiny clock again.
  const temporaryDigit = document.createElement("div");
  temporaryDigit.classList.add("digit");

  const temporaryTinyClock = document.createElement("div");
  temporaryTinyClock.classList.add("∅");

  temporaryDigit.append(temporaryTinyClock);
  target.append(temporaryDigit);

  const shapes = ["┌", "┐", "┘", "└", "─", "│", "∅"];
  const shapeStyle = window.getComputedStyle(temporaryTinyClock);
  shapes.forEach((shape) => {
    temporaryTinyClock.setAttribute("class", shape);

    const desiredAngleA = read(shapeStyle, "--angle-hour");
    const desiredAngleB = read(shapeStyle, "--angle-minute");

    degrees[shape] = [desiredAngleA, desiredAngleB];
  });

  temporaryDigit.remove();

  // Store the live collections for each digit

  // Finally, start the clock
  let lastDisplayedTime = 0;

  function check() {
    const now = new Date();
    const displayedNow = Math.floor(now.getTime() % 1000);

    if (lastDisplayedTime != displayedNow) {
      lastDisplayedTime = displayedNow;
      redraw(now);
    }

    requestAnimationFrame(check);
  }

  function redraw(now: Date) {
    const hours = now.getHours();
    const minutes = now.getMinutes();
    const seconds = now.getSeconds();

    const digits = [
      Math.floor(hours / 10),
      hours % 10,
      Math.floor(minutes / 10),
      minutes % 10,
      Math.floor(seconds / 10),
      seconds % 10,
    ];

    digits.forEach((digit, index) => {
      draw(digit, collections[index]);
    });
  }

  requestAnimationFrame(check);
</script>
